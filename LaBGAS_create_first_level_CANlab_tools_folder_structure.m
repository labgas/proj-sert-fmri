%% LaBGAS_create_first_level_CANlab_tools_folder_structure
%
% This simple script 
% 1) creates the folder structure for first level analysis for Nathalie's 
% emotional modulation of visceral pain study using CANlab tools
% 2) copies noise regressor and onset files generated by
% LaBGAS_extract_confound_reg_fMRIprep.m and written to dir 'firstlevel' to
% run-specific directories in 'derivatives\fmriprep' as this is consistent 
% with organization required by LaBGAS_get_firstlvl_dsgn_obj and
% LaBGAS_1_spm_fit_firstlvl_models
%
% NOTES TO SELF from @lukasvo76: 
% 1) may be better to adapt LaBGAS_extract_confound_reg_fMRIprep.m 
% to write confound regressors to dir 'derivatives' directly 
% for future purposes, which is easy to implement
% 2) may be better to work with hierarchical folder structure for future
% purposes, for example firstlevel\model1, \model2, etc
%
%__________________________________________________________________________
%
% author: lukas.vanoudenhove@kuleuven.be
% date:   October, 2020
%__________________________________________________________________________
% @(#)% LaBGAS_create_first_level_CANlab_tools_folder_structure.m     v1.0        
% last modified: 2020/10/19

%% define directories and make new first level directory
rootdir='C:\Users\lukas\Dropbox (Personal)\proj-SERT-fMRI';
cd(rootdir);
mkdir('firstlevel_CANlab_tools');
firstleveldir=fullfile(rootdir,'firstlevel');
firstlevelcanlabdir=fullfile(rootdir,'firstlevel_CANlab_tools');
fmriprepdir=fullfile(rootdir,'derivatives\fmriprep');

%% get subject folder names from derivatives\fmriprep
cd(fmriprepdir);
subjs=dir('sub-*');
idx=[subjs.isdir]';
subjs={subjs(idx).name}';

%% define anonymous function sm to write folder structure with cell array of folder names as input
sm=@(x)spm_mkdir(x); % defines spm_mkdir as an anonymous function sm

%% write folder structure in new first level directory
cd(firstlevelcanlabdir);
cellfun(sm,subjs); % applies function sm to all cells of subjs

%% loop over subjects to copy and move the onsets, noise_regs, functional scans, and fmriprep confound files to subdirectories per run (which equals condition in our case)
for i=1:length(subjs)
    subjfirstleveldir=fullfile(firstleveldir,subjs{i});
    subjfmriprepdir=fullfile(fmriprepdir,subjs{i},'func');
    cd(subjfirstleveldir);
    onset_files=ls('onset*.mat');
    noise_files=ls('noise*.txt');
    [nr_noise_files,~] = size(noise_files);
    [nr_onset_files,~] = size(onset_files);
%     for j=1:nr_noise_files
%         copyfile(fullfile(subjfirstleveldir,noise_files(j,:)),fullfile(subjfmriprepdir,noise_files(j,:)));
%         copyfile(fullfile(subjfirstleveldir,onset_files(j,:)),fullfile(subjfmriprepdir,onset_files(j,:)));
%     end
    cd(subjfmriprepdir);
%     noise_mat_files=ls('noise*.mat');
%     [nr_noise_mat_files,~] = size(noise_mat_files);
%     for k=1:nr_noise_mat_files
%         delete(noise_mat_files(k,:));
%     end
    conds={'neg';'neu';'pos'};
    cellfun(sm,conds);
    niigz_files=ls('s6*.nii.gz');
    niigz_files=cellstr(niigz_files);
    idx=~contains(niigz_files,"rest");
    niigz_files=niigz_files(idx);
    fmriprepconf_files=ls('sub*.tsv');
    fmriprepconf_files=cellstr(fmriprepconf_files);
    idx=~contains(fmriprepconf_files,"rest");
    fmriprepconf_files=fmriprepconf_files(idx);
    if ~isequal(nr_noise_files,nr_onset_files,length(niigz_files),length(fmriprepconf_files))
        error('number of onset, noise, functional, and fmriprep confound files does not match');
    else
        for m=1:length(niigz_files)
            gunzip(niigz_files{m});
            niifile=ls('s6*.nii');
            rundir=fullfile(subjfmriprepdir,conds{m});
            movefile(fullfile(subjfmriprepdir,niifile),fullfile(rundir,niifile));
            movefile(fullfile(subjfmriprepdir,onset_files(m,:)),fullfile(rundir,onset_files(m,:)));
            movefile(fullfile(subjfmriprepdir,noise_files(m,:)),fullfile(rundir,noise_files(m,:)));
            copyfile(fullfile(subjfmriprepdir,fmriprepconf_files{m,:}),fullfile(rundir,fmriprepconf_files{m,:}));
        end
    end
end